# $Id: avrdude.conf.in 1236 2013-09-16 19:40:15Z joerg_wunsch $ -*- text -*-
#
# AVRDUDE Configuration File
#
# This file contains configuration data used by AVRDUDE which describes
# the programming hardware pinouts and also provides part definitions.
# AVRDUDE's "-C" command line option specifies the location of the
# configuration file.  The "-c" option names the programmer configuration
# which must match one of the entry's "id" parameter.  The "-p" option
# identifies which part AVRDUDE is going to be programming and must match
# one of the parts' "id" parameter.
#
# Possible entry formats are:
#
#   programmer
#       parent <id>                                 # optional parent
#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
#       desc     = <description> ;                  # quoted string
#       type     = <type>;                          # programmer type, quoted string
#                          # supported programmer types can be listed by "-c ?type"
#       connection_type = parallel | serial | usb
#       baudrate = <num> ;                          # baudrate for avr910-programmer
#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
#       buff     = <num1> [, <num2> ... ] ;         # pin number(s)
#       reset    = <num> ;                          # pin number
#       sck      = <num> ;                          # pin number
#       mosi     = <num> ;                          # pin number
#       miso     = <num> ;                          # pin number
#       errled   = <num> ;                          # pin number
#       rdyled   = <num> ;                          # pin number
#       pgmled   = <num> ;                          # pin number
#       vfyled   = <num> ;                          # pin number
#       usbvid   = <hexnum>;                        # USB VID (Vendor ID)
#       usbpid   = <hexnum>;                        # USB PID (Product ID)
#       usbdev   = <interface>;                     # USB interface or other device info
#       usbvendor = <vendorname>;                   # USB Vendor Name
#       usbproduct = <productname>;                 # USB Product Name
#       usbsn    = <serialno>;                      # USB Serial Number
#
#        To invert a bit, use = ~ <num>, the spaces are important.
#        For a pin list all pins must be inverted.
#        A single pin can be specified as usual = ~ <num>, for lists
#        specify it as follows = ~ ( <num> [, <num2> ... ] ) .
#     ;
#
#   part
#       id               = <id> ;                 # quoted string
#       desc             = <description> ;        # quoted string
#       has_jtag         = <yes/no> ;             # part has JTAG i/f
#       has_debugwire    = <yes/no> ;             # part has debugWire i/f
#       has_pdi          = <yes/no> ;             # part has PDI i/f
#       has_tpi          = <yes/no> ;             # part has TPI i/f
#       devicecode       = <num> ;            # deprecated, use stk500_devcode
#       stk500_devcode   = <num> ;                # numeric
#       avr910_devcode   = <num> ;                # numeric
#       signature        = <num> <num> <num> ;    # signature bytes
#       chip_erase_delay = <num> ;                # micro-seconds
#       reset            = dedicated | io;
#       retry_pulse      = reset | sck;
#       pgm_enable       = <instruction format> ;
#       chip_erase       = <instruction format> ;
#       chip_erase_delay = <num> ;                # chip erase delay (us)
#       # STK500 parameters (parallel programming IO lines)
#       pagel            = <num> ;                # pin name in hex, i.e., 0xD7
#       bs2              = <num> ;                # pin name in hex, i.e., 0xA0
#       serial           = <yes/no> ;             # can use serial downloading
#       parallel         = <yes/no/pseudo>;       # can use par. programming
#       # STK500v2 parameters, to be taken from Atmel's XML files
#       timeout          = <num> ;
#       stabdelay        = <num> ;
#       cmdexedelay      = <num> ;
#       synchloops       = <num> ;
#       bytedelay        = <num> ;
#       pollvalue        = <num> ;
#       pollindex        = <num> ;
#       predelay         = <num> ;
#       postdelay        = <num> ;
#       pollmethod       = <num> ;
#       mode             = <num> ;
#       delay            = <num> ;
#       blocksize        = <num> ;
#       readsize         = <num> ;
#       hvspcmdexedelay  = <num> ;
#       # STK500v2 HV programming parameters, from XML
#       pp_controlstack  = <num>, <num>, ...;   # PP only
#       hvsp_controlstack = <num>, <num>, ...;  # HVSP only
#       hventerstabdelay = <num>;
#       progmodedelay    = <num>;               # PP only
#       latchcycles      = <num>;
#       togglevtg        = <num>;
#       poweroffdelay    = <num>;
#       resetdelayms     = <num>;
#       resetdelayus     = <num>;
#       hvleavestabdelay = <num>;
#       resetdelay       = <num>;
#       synchcycles      = <num>;               # HVSP only
#       chiperasepulsewidth = <num>;            # PP only
#       chiperasepolltimeout = <num>;
#       chiperasetime    = <num>;               # HVSP only
#       programfusepulsewidth = <num>;          # PP only
#       programfusepolltimeout = <num>;
#       programlockpulsewidth = <num>;          # PP only
#       programlockpolltimeout = <num>;
#       # JTAG ICE mkII parameters, also from XML files
#       allowfullpagebitstream = <yes/no> ;
#       enablepageprogramming = <yes/no> ;
#       idr              = <num> ;                # IO addr of IDR (OCD) reg.
#       rampz            = <num> ;                # IO addr of RAMPZ reg.
#       spmcr            = <num> ;                # mem addr of SPMC[S]R reg.
#       eecr             = <num> ;                # mem addr of EECR reg.
#                                                 # (only when != 0x3c)
#       is_at90s1200     = <yes/no> ;             # AT90S1200 part
#       is_avr32         = <yes/no> ;             # AVR32 part
#
#       memory <memtype>
#           paged           = <yes/no> ;          # yes / no
#           size            = <num> ;             # bytes
#           page_size       = <num> ;             # bytes
#           num_pages       = <num> ;             # numeric
#           min_write_delay = <num> ;             # micro-seconds
#           max_write_delay = <num> ;             # micro-seconds
#           readback_p1     = <num> ;             # byte value
#           readback_p2     = <num> ;             # byte value
#           pwroff_after_write = <yes/no> ;       # yes / no
#           read            = <instruction format> ;
#           write           = <instruction format> ;
#           read_lo         = <instruction format> ;
#           read_hi         = <instruction format> ;
#           write_lo        = <instruction format> ;
#           write_hi        = <instruction format> ;
#           loadpage_lo     = <instruction format> ;
#           loadpage_hi     = <instruction format> ;
#           writepage       = <instruction format> ;
#         ;
#     ;
#
# If any of the above parameters are not specified, the default value
# of 0 is used for numerics or the empty string ("") for string
# values.  If a required parameter is left empty, AVRDUDE will
# complain.
#
# Parts can also inherit parameters from previously defined parts
# using the following syntax. In this case specified integer and
# string values override parameter values from the parent part. New
# memory definitions are added to the definitions inherited from the
# parent.
#
#   part parent <id>                              # quoted string
#       id               = <id> ;                 # quoted string
#       <any set of other parameters from the list above>
#     ;
#
# NOTES:
#   * 'devicecode' is the device code used by the STK500 (see codes
#       listed below)
#   * Not all memory types will implement all instructions.
#   * AVR Fuse bits and Lock bits are implemented as a type of memory.
#   * Example memory types are:
#       "flash", "eeprom", "fuse", "lfuse" (low fuse), "hfuse" (high
#       fuse), "signature", "calibration", "lock"
#   * The memory type specified on the avrdude command line must match
#     one of the memory types defined for the specified chip.
#   * The pwroff_after_write flag causes avrdude to attempt to
#     power the device off and back on after an unsuccessful write to
#     the affected memory area if VCC programmer pins are defined.  If
#     VCC pins are not defined for the programmer, a message
#     indicating that the device needs a power-cycle is printed out.
#     This flag was added to work around a problem with the
#     at90s4433/2333's; see the at90s4433 errata at:
#
#         http://www.atmel.com/dyn/resources/prod_documents/doc1280.pdf
#
# INSTRUCTION FORMATS
#
#    Instruction formats are specified as a comma separated list of
#    string values containing information (bit specifiers) about each
#    of the 32 bits of the instruction.  Bit specifiers may be one of
#    the following formats:
#
#       '1'  = the bit is always set on input as well as output
#
#       '0'  = the bit is always clear on input as well as output
#
#       'x'  = the bit is ignored on input and output
#
#       'a'  = the bit is an address bit, the bit-number matches this bit
#              specifier's position within the current instruction byte
#
#       'aN' = the bit is the Nth address bit, bit-number = N, i.e., a12
#              is address bit 12 on input, a0 is address bit 0.
#
#       'i'  = the bit is an input data bit
#
#       'o'  = the bit is an output data bit
#
#    Each instruction must be composed of 32 bit specifiers.  The
#    instruction specification closely follows the instruction data
#    provided in Atmel's data sheets for their parts.
#
# See below for some examples.
#
#
# The following are STK500 part device codes to use for the
# "devicecode" field of the part.  These came from Atmel's software
# section avr061.zip which accompanies the application note
# AVR061 available from:
#
#      http://www.atmel.com/dyn/resources/prod_documents/doc2525.pdf
#

#define ATTINY10    0x10  /* the _old_ one that never existed! */
#define ATTINY11    0x11
#define ATTINY12    0x12
#define ATTINY15    0x13
#define ATTINY13    0x14

#define ATTINY22    0x20
#define ATTINY26    0x21
#define ATTINY28    0x22
#define ATTINY2313  0x23

#define AT90S1200   0x33

#define AT90S2313   0x40
#define AT90S2323   0x41
#define AT90S2333   0x42
#define AT90S2343   0x43

#define AT90S4414   0x50
#define AT90S4433   0x51
#define AT90S4434   0x52
#define ATMEGA48    0x59

#define AT90S8515   0x60
#define AT90S8535   0x61
#define AT90C8534   0x62
#define ATMEGA8515  0x63
#define ATMEGA8535  0x64

#define ATMEGA8     0x70
#define ATMEGA88    0x73
#define ATMEGA168   0x86

#define ATMEGA161   0x80
#define ATMEGA163   0x81
#define ATMEGA16    0x82
#define ATMEGA162   0x83
#define ATMEGA169   0x84

#define ATMEGA323   0x90
#define ATMEGA32    0x91

#define ATMEGA64    0xA0

#define ATMEGA103   0xB1
#define ATMEGA128   0xB2
#define AT90CAN128  0xB3
#define AT90CAN64   0xB3
#define AT90CAN32   0xB3

#define AT86RF401   0xD0

#define AT89START   0xE0
#define AT89S51     0xE0
#define AT89S52     0xE1

# The following table lists the devices in the original AVR910
# appnote:
# |Device |Signature | Code |
# +-------+----------+------+
# |tiny12 | 1E 90 05 | 0x55 |
# |tiny15 | 1E 90 06 | 0x56 |
# |       |          |      |
# | S1200 | 1E 90 01 | 0x13 |
# |       |          |      |
# | S2313 | 1E 91 01 | 0x20 |
# | S2323 | 1E 91 02 | 0x48 |
# | S2333 | 1E 91 05 | 0x34 |
# | S2343 | 1E 91 03 | 0x4C |
# |       |          |      |
# | S4414 | 1E 92 01 | 0x28 |
# | S4433 | 1E 92 03 | 0x30 |
# | S4434 | 1E 92 02 | 0x6C |
# |       |          |      |
# | S8515 | 1E 93 01 | 0x38 |
# | S8535 | 1E 93 03 | 0x68 |
# |       |          |      |
# |mega32 | 1E 95 01 | 0x72 |
# |mega83 | 1E 93 05 | 0x65 |
# |mega103| 1E 97 01 | 0x41 |
# |mega161| 1E 94 01 | 0x60 |
# |mega163| 1E 94 02 | 0x64 |

# Appnote AVR109 also has a table of AVR910 device codes, which
# lists:
# dev         avr910   signature
# ATmega8     0x77     0x1E 0x93 0x07
# ATmega8515  0x3B     0x1E 0x93 0x06
# ATmega8535  0x6A     0x1E 0x93 0x08
# ATmega16    0x75     0x1E 0x94 0x03
# ATmega162   0x63     0x1E 0x94 0x04
# ATmega163   0x66     0x1E 0x94 0x02
# ATmega169   0x79     0x1E 0x94 0x05
# ATmega32    0x7F     0x1E 0x95 0x02
# ATmega323   0x73     0x1E 0x95 0x01
# ATmega64    0x46     0x1E 0x96 0x02
# ATmega128   0x44     0x1E 0x97 0x02
#
# These codes refer to "BOOT" device codes which are apparently
# different than standard device codes, for whatever reasons
# (often one above the standard code).

# There are several extended versions of AVR910 implementations around
# in the Internet.  These add the following codes (only devices that
# actually exist are listed):

# ATmega8515  0x3A
# ATmega128 0x43
# ATmega64  0x45
# ATtiny26  0x5E
# ATmega8535  0x69
# ATmega32  0x72
# ATmega16  0x74
# ATmega8 0x76
# ATmega169 0x78

#
# Overall avrdude defaults; suitable for ~/.avrduderc
#
default_parallel   = "lpt1";
default_serial     = "com1";
default_bitclock = 5;

# Turn off safemode by default
#default_safemode  = no;


#
# PROGRAMMER DEFINITIONS
#

# http://wiring.org.co/
# Basically STK500v2 protocol, with some glue to trigger the
# bootloader.
programmer
  id    = "wiring";
  desc  = "Wiring";
  type  = "wiring";
  connection_type = serial;
;

programmer
  id    = "arduino";
  desc  = "Arduino";
  type  = "arduino";
  connection_type = serial;
;
# this will interface with the chips on these programmers:
#
# http://real.kiev.ua/old/avreal/en/adapters
# http://www.amontec.com/jtagkey.shtml, jtagkey-tiny.shtml
# http://www.olimex.com/dev/arm-usb-ocd.html, arm-usb-tiny.html
# http://www.ethernut.de/en/hardware/turtelizer/index.html
# http://elk.informatik.fh-augsburg.de/hhweb/doc/openocd/usbjtag/usbjtag.html
# http://dangerousprototypes.com/docs/FT2232_breakout_board
# http://www.ftdichip.com/Products/Modules/DLPModules.htm,DLP-2232*,DLP-USB1232H
# http://flashrom.org/FT2232SPI_Programmer
#
# The drivers will look for a specific device and use the first one found.
# If you have multiple devices, then look for unique information (like SN)
# And fill that in here.
#
# Note that the pin numbers for the main ISP signals (reset, sck,
# mosi, miso) are fixed and cannot be changed, since they must match
# the way the Multi-Protocol Synchronous Serial Engine (MPSSE) of
# these FTDI ICs has been designed.

programmer
  id         = "avrftdi";
  desc       = "FT2232D based generic programmer";
  type       = "avrftdi";
  connection_type = usb;
  usbvid     = 0x0403;
  usbpid     = 0x6010;
  usbvendor  = "";
  usbproduct = "";
  usbdev     = "A";
  usbsn      = "";
#ISP-signals - lower ADBUS-Nibble (default)
  reset  = 3;
  sck    = 0;
  mosi   = 1;
  miso   = 2;
#LED SIGNALs - higher ADBUS-Nibble
#  errled = 4;
#  rdyled = 5;
#  pgmled = 6;
#  vfyled = 7;
#Buffer Signal - ACBUS - Nibble
#  buff   = 8;
;
# This is an implementation of the above with a buffer IC (74AC244) and
# 4 LEDs directly attached, all active low.
programmer
  id         = "2232HIO";
  desc       = "FT2232H based generic programmer";
  type       = "avrftdi";
  connection_type = usb;
  usbvid     = 0x0403;
# Note: This PID is reserved for generic H devices and
# should be programmed into the EEPROM
#  usbpid     = 0x8A48;
  usbpid     = 0x6010;
  usbdev     = "A";
  usbvendor  = "";
  usbproduct = "";
  usbsn      = "";
#ISP-signals
  reset  = 3;
  sck    = 0;
  mosi   = 1;
  miso   = 2;
  buff   = ~4;
#LED SIGNALs
  errled = ~ 11;
  rdyled = ~ 14;
  pgmled = ~ 13;
  vfyled = ~ 12;
;

#The FT4232H can be treated as FT2232H, but it has a different USB
#device ID of 0x6011.
programmer parent "avrftdi"
  id         = "4232h";
  desc       = "FT4232H based generic programmer";
  usbpid     = 0x6011;
;

programmer
  id         = "jtagkey";
  desc       = "Amontec JTAGKey, JTAGKey-Tiny and JTAGKey2";
  type       = "avrftdi";
  connection_type = usb;
  usbvid     = 0x0403;
# Note: This PID is used in all JTAGKey variants
  usbpid     = 0xCFF8;
  usbdev     = "A";
  usbvendor  = "";
  usbproduct = "";
  usbsn      = "";
#ISP-signals => 20 - Pin connector on JTAGKey
  reset  = 3; # TMS 7 violet
  sck    = 0; # TCK 9 white
  mosi   = 1; # TDI 5 green
  miso   = 2; # TDO 13 orange
  buff   = ~4;
# VTG           VREF 1 brown with red tip
# GND           GND 20 black
# The colors are on the 20 pin breakout cable
# from Amontec
;

# On the adapter you can read "O-Link". On the PCB is printed "OpenJTAG v3.1"
# You can find it as "OpenJTAG ARM JTAG USB" in the internet.
# (But there are also several projects called Open JTAG, eg.
# http://www.openjtag.org, which are completely different.)
#   http://www.100ask.net/shop/english.html (website seems to be outdated)
#   http://item.taobao.com/item.htm?id=1559277013
#   http://www.micro4you.com/store/openjtag-arm-jtag-usb.html (schematics!)
# some other sources which call it O-Link
#   http://www.andahammer.com/olink/
#   http://www.developmentboard.net/31-o-link-debugger.html
#   http://armwerks.com/catalog/o-link-debugger-copy/
# or just have a look at ebay ...
# It is basically the same entry as jtagkey with different usb ids.
programmer parent "jtagkey"
  id         = "o-link";
  desc       = "O-Link, OpenJTAG from www.100ask.net";
  usbvid     = 0x1457;
  usbpid     = 0x5118;
  usbvendor  = "www.100ask.net";
  usbproduct = "USB<=>JTAG&RS232";
;

# http://wiki.openmoko.org/wiki/Debug_Board_v3
programmer
  id    = "openmoko";
  desc  = "Openmoko debug board (v3)";
  type  = "avrftdi";
  usbvid     = 0x1457;
  usbpid    = 0x5118;
  usbdev = "A";
  usbvendor  = "";
  usbproduct = "";
  usbsn      = "";
  reset  = 3; # TMS 7
  sck    = 0; # TCK 9
  mosi   = 1; # TDI 5
  miso   = 2; # TDO 13
;

# Only Rev. A boards.
# Schematic and user manual: http://www.cs.put.poznan.pl/wswitala/download/pdf/811EVBK.pdf
programmer
  id         = "lm3s811";
  desc       = "Luminary Micro LM3S811 Eval Board (Rev. A)";
  type       = "avrftdi";
  connection_type = usb;
  usbvid     = 0x0403;
  usbpid     = 0xbcd9;
  usbvendor  = "LMI";
  usbproduct = "LM3S811 Evaluation Board";
  usbdev     = "A";
  usbsn      = "";
#ISP-signals - lower ACBUS-Nibble (default)
  reset  = 3;
  sck    = 0;
  mosi   = 1;
  miso   = 2;
# Enable correct buffers
  buff   = 7;
;

programmer
  id    = "avrisp";
  desc  = "Atmel AVR ISP";
  type  = "stk500";
  connection_type = serial;
;

programmer
  id    = "avrispv2";
  desc  = "Atmel AVR ISP V2";
  type  =  "stk500v2";
  connection_type = serial;
;

programmer
  id    = "avrispmkII";
  desc  = "Atmel AVR ISP mkII";
  type  =  "stk500v2";
  connection_type = usb;
;

programmer parent "avrispmkII"
  id    = "avrisp2";
;

programmer
  id    = "buspirate";
  desc  = "The Bus Pirate";
  type  = "buspirate";
  connection_type = serial;
;

programmer
  id    = "buspirate_bb";
  desc  = "The Bus Pirate (bitbang interface, supports TPI)";
  type  = "buspirate_bb";
  connection_type = serial;
  # pins are bits in bitbang byte (numbers are 87654321)
  # 1|POWER|PULLUP|AUX|MOSI|CLK|MISO|CS
  reset  = 1;
  sck    = 3;
  mosi   = 4;
  miso   = 2;
  #vcc    = 7; This is internally set independent of this setting.
;

# This is supposed to be the "default" STK500 entry.
# Attempts to select the correct firmware version
# by probing for it.  Better use one of the entries
# below instead.
programmer
  id    = "stk500";
  desc  = "Atmel STK500";
  type  = "stk500generic";
  connection_type = serial;
;

programmer
  id    = "stk500v1";
  desc  = "Atmel STK500 Version 1.x firmware";
  type  = "stk500";
  connection_type = serial;
;

programmer
  id    = "mib510";
  desc  = "Crossbow MIB510 programming board";
  type  = "stk500";
  connection_type = serial;
;

programmer
  id    = "stk500v2";
  desc  = "Atmel STK500 Version 2.x firmware";
  type  = "stk500v2";
  connection_type = serial;
;

programmer
  id    = "stk500pp";
  desc  = "Atmel STK500 V2 in parallel programming mode";
  type  = "stk500pp";
  connection_type = serial;
;

programmer
  id    = "stk500hvsp";
  desc  = "Atmel STK500 V2 in high-voltage serial programming mode";
  type  = "stk500hvsp";
  connection_type = serial;
;

programmer
  id    = "stk600";
  desc  = "Atmel STK600";
  type  = "stk600";
  connection_type = usb;
;

programmer
  id    = "stk600pp";
  desc  = "Atmel STK600 in parallel programming mode";
  type  = "stk600pp";
  connection_type = usb;
;

programmer
  id    = "stk600hvsp";
  desc  = "Atmel STK600 in high-voltage serial programming mode";
  type  = "stk600hvsp";
  connection_type = usb;
;

programmer
  id    = "avr910";
  desc  = "Atmel Low Cost Serial Programmer";
  type  = "avr910";
  connection_type = serial;
;

programmer
  id    = "ft245r";
  desc  = "FT245R Synchronous BitBang";
  type  = "ftdi_syncbb";
  connection_type = usb;
  miso  = 1; # D1
  sck   = 0; # D0
  mosi  = 2; # D2
  reset = 4; # D4
;

programmer
  id    = "ft232r";
  desc  = "FT232R Synchronous BitBang";
  type  = "ftdi_syncbb";
  connection_type = usb;
  miso  = 1;  # RxD
  sck   = 0;  # RTS
  mosi  = 2;  # TxD
  reset = 4;  # DTR
;

# see http://www.bitwizard.nl/wiki/index.php/FTDI_ATmega
programmer
  id    = "bwmega";
  desc  = "BitWizard ftdi_atmega builtin programmer";
  type  = "ftdi_syncbb";
  connection_type = usb;
  miso  = 5;  # DSR
  sck   = 6;  # DCD
  mosi  = 3;  # CTS
  reset = 7;  # RI
;

# see http://www.geocities.jp/arduino_diecimila/bootloader/index_en.html
# Note: pins are numbered from 1!
programmer
  id    = "arduino-ft232r";
  desc  = "Arduino: FT232R connected to ISP";
  type  = "ftdi_syncbb";
  connection_type = usb;
  miso  = 3;  # CTS X3(1)
  sck   = 5;  # DSR X3(2)
  mosi  = 6;  # DCD X3(3)
  reset = 7;  # RI  X3(4)
;

# website mentioned above uses this id
programmer parent "arduino-ft232r"
  id    = "diecimila";
  desc  = "alias for arduino-ft232r";
;

programmer
  id    = "usbasp";
  desc  = "USBasp, http://www.fischl.de/usbasp/";
  type  = "usbasp";
  connection_type = usb;
  usbvid     = 0x16C0; # VOTI
  usbpid     = 0x05DC; # Obdev's free shared PID
  usbvendor  = "www.fischl.de";
  usbproduct = "USBasp";

  # following variants are autodetected for id "usbasp"

  # original usbasp from fischl.de
  # see above "usbasp"

  # old usbasp from fischl.de
  #usbvid     = 0x03EB; # ATMEL
  #usbpid     = 0xC7B4; # (unofficial) USBasp
  #usbvendor  = "www.fischl.de";
  #usbproduct = "USBasp";

  # NIBObee (only if -P nibobee is given on command line)
  # see below "nibobee"
;

programmer
  id    = "nibobee";
  desc  = "NIBObee";
  type  = "usbasp";
  connection_type = usb;
  usbvid     = 0x16C0; # VOTI
  usbpid     = 0x092F; # NIBObee PID
  usbvendor  = "www.nicai-systems.com";
  usbproduct = "NIBObee";
;

programmer
  id    = "usbasp-clone";
  desc  = "Any usbasp clone with correct VID/PID";
  type  = "usbasp";
  connection_type = usb;
  usbvid    = 0x16C0; # VOTI
  usbpid    = 0x05DC; # Obdev's free shared PID
  #usbvendor  = "";
  #usbproduct = "";
;

programmer
  id    = "usbtiny";
  desc  = "USBtiny simple USB programmer, http://www.ladyada.net/make/usbtinyisp/";
  type  = "usbtiny";
  connection_type = usb;
  usbvid     = 0x1781;
  usbpid     = 0x0c9f;
;

programmer
  id    = "arduinoisp";
  desc  = " ";
  type  = "usbtiny";
  connection_type = usb;
  usbvid     = 0x2341;
  usbpid     = 0x0049;
;

programmer
  id    = "butterfly";
  desc  = "Atmel Butterfly Development Board";
  type  = "butterfly";
  connection_type = serial;
;

programmer
  id    = "avr109";
  desc  = "Atmel AppNote AVR109 Boot Loader";
  type  = "butterfly";
  connection_type = serial;
;

programmer
  id    = "avr911";
  desc  = "Atmel AppNote AVR911 AVROSP";
  type  = "butterfly";
  connection_type = serial;
;

# suggested in http://forum.mikrokopter.de/topic-post48317.html
programmer
  id    = "mkbutterfly";
  desc  = "Mikrokopter.de Butterfly";
  type  = "butterfly_mk";
  connection_type = serial;
;

programmer parent "mkbutterfly"
  id    = "butterfly_mk";
;

programmer
  id    = "jtagmkI";
  desc  = "Atmel JTAG ICE (mkI)";
  baudrate = 115200;    # default is 115200
  type  = "jtagmki";
  connection_type = serial;
;

# easier to type
programmer parent "jtagmkI"
  id    = "jtag1";
;

# easier to type
programmer parent "jtag1"
  id    = "jtag1slow";
  baudrate = 19200;
;

# The JTAG ICE mkII has both, serial and USB connectivity.  As it is
# mostly used through USB these days (AVR Studio 5 only supporting it
# that way), we make connection_type = usb the default.  Users are
# still free to use a serial port with the -P option.

programmer
  id    = "jtagmkII";
  desc  = "Atmel JTAG ICE mkII";
  baudrate = 19200;    # default is 19200
  type  = "jtagmkii";
  connection_type = usb;
;

# easier to type
programmer parent "jtagmkII"
  id    = "jtag2slow";
;

# JTAG ICE mkII @ 115200 Bd
programmer parent "jtag2slow"
  id    = "jtag2fast";
  baudrate = 115200;
;

# make the fast one the default, people will love that
programmer parent "jtag2fast"
  id    = "jtag2";
;

# JTAG ICE mkII in ISP mode
programmer
  id    = "jtag2isp";
  desc  = "Atmel JTAG ICE mkII in ISP mode";
  baudrate = 115200;
  type  = "jtagmkii_isp";
  connection_type = usb;
;

# JTAG ICE mkII in debugWire mode
programmer
  id    = "jtag2dw";
  desc  = "Atmel JTAG ICE mkII in debugWire mode";
  baudrate = 115200;
  type  = "jtagmkii_dw";
  connection_type = usb;
;

# JTAG ICE mkII in AVR32 mode
programmer
  id    = "jtagmkII_avr32";
  desc  = "Atmel JTAG ICE mkII im AVR32 mode";
  baudrate = 115200;
  type  = "jtagmkii_avr32";
  connection_type = usb;
;

# JTAG ICE mkII in AVR32 mode
programmer
  id    = "jtag2avr32";
  desc  = "Atmel JTAG ICE mkII im AVR32 mode";
  baudrate = 115200;
  type  = "jtagmkii_avr32";
  connection_type = usb;
;

# JTAG ICE mkII in PDI mode
programmer
  id    = "jtag2pdi";
  desc  = "Atmel JTAG ICE mkII PDI mode";
  baudrate = 115200;
  type  = "jtagmkii_pdi";
  connection_type = usb;
;

# AVR Dragon in JTAG mode
programmer
  id    = "dragon_jtag";
  desc  = "Atmel AVR Dragon in JTAG mode";
  baudrate = 115200;
  type  = "dragon_jtag";
  connection_type = usb;
;

# AVR Dragon in ISP mode
programmer
  id    = "dragon_isp";
  desc  = "Atmel AVR Dragon in ISP mode";
  baudrate = 115200;
  type  = "dragon_isp";
  connection_type = usb;
;

# AVR Dragon in PP mode
programmer
  id    = "dragon_pp";
  desc  = "Atmel AVR Dragon in PP mode";
  baudrate = 115200;
  type  = "dragon_pp";
  connection_type = usb;
;

# AVR Dragon in HVSP mode
programmer
  id    = "dragon_hvsp";
  desc  = "Atmel AVR Dragon in HVSP mode";
  baudrate = 115200;
  type  = "dragon_hvsp";
  connection_type = usb;
;

# AVR Dragon in debugWire mode
programmer
  id    = "dragon_dw";
  desc  = "Atmel AVR Dragon in debugWire mode";
  baudrate = 115200;
  type  = "dragon_dw";
  connection_type = usb;
;

# AVR Dragon in PDI mode
programmer
  id    = "dragon_pdi";
  desc  = "Atmel AVR Dragon in PDI mode";
  baudrate = 115200;
  type  = "dragon_pdi";
  connection_type = usb;
;

programmer
  id    = "jtag3";
  desc  = "Atmel AVR JTAGICE3 in JTAG mode";
  type  = "jtagice3";
  connection_type = usb;
;

programmer
  id    = "jtag3pdi";
  desc  = "Atmel AVR JTAGICE3 in PDI mode";
  type  = "jtagice3_pdi";
  connection_type = usb;
;

programmer
  id    = "jtag3dw";
  desc  = "Atmel AVR JTAGICE3 in debugWIRE mode";
  type  = "jtagice3_dw";
  connection_type = usb;
;

programmer
  id    = "jtag3isp";
  desc  = "Atmel AVR JTAGICE3 in ISP mode";
  type  = "jtagice3_isp";
  connection_type = usb;
;

programmer
  id    = "atmelice";
  desc  = "Atmel-ICE (ARM/AVR) in JTAG mode";
  type  = "jtagice3";
  connection_type = usb;
  usbpid = 0x2141;
;

programmer
  id    = "atmelice_pdi";
  desc  = "Atmel-ICE (ARM/AVR) in PDI mode";
  type  = "jtagice3_pdi";
  connection_type = usb;
  usbpid = 0x2141;
;


programmer
  id    = "atmelice_dw";
  desc  = "Atmel-ICE (ARM/AVR) in debugWIRE mode";
  type  = "jtagice3_dw";
  connection_type = usb;
  usbpid = 0x2141;
;

programmer
  id    = "atmelice_isp";
  desc  = "Atmel-ICE (ARM/AVR) in ISP mode";
  type  = "jtagice3_isp";
  connection_type = usb;
  usbpid = 0x2141;
;

programmer
  id    = "pavr";
  desc  = "Jason Kyle's pAVR Serial Programmer";
  type  = "avr910";
  connection_type = serial;
;

programmer
  id    = "pickit2";
  desc  = "MicroChip's PICkit2 Programmer";
  type  = "pickit2";
  connection_type = usb;
;

# Parallel port programmers.

programmer
  id    = "bsd";
  desc  = "Brian Dean's Programmer, http://www.bsdhome.com/avrdude/";
  type  = "par";
  connection_type = parallel;
  vcc   = 2, 3, 4, 5;
  reset = 7;
  sck   = 8;
  mosi  = 9;
  miso  = 10;
;

programmer
  id    = "stk200";
  desc  = "STK200";
  type  = "par";
  connection_type = parallel;
  buff  = 4, 5;
  sck   = 6;
  mosi  = 7;
  reset = 9;
  miso  = 10;
;

# The programming dongle used by the popular Ponyprog
# utility.  It is almost similar to the STK200 one,
# except that there is a LED indicating that the
# programming is currently in progress.

programmer parent "stk200"
  id    = "pony-stk200";
  desc  = "Pony Prog STK200";
  pgmled = 8;
;

programmer
  id    = "dt006";
  desc  = "Dontronics DT006";
  type  = "par";
  connection_type = parallel;
  reset = 4;
  sck   = 5;
  mosi  = 2;
  miso  = 11;
;

programmer parent "dt006"
  id    = "bascom";
  desc  = "Bascom SAMPLE programming cable";
;

programmer
  id     = "alf";
  desc   = "Nightshade ALF-PgmAVR, http://nightshade.homeip.net/";
  type   = "par";
  connection_type = parallel;
  vcc    = 2, 3, 4, 5;
  buff   = 6;
  reset  = 7;
  sck    = 8;
  mosi   = 9;
  miso   = 10;
  errled = 1;
  rdyled = 14;
  pgmled = 16;
  vfyled = 17;
;

programmer
  id    = "sp12";
  desc  = "Steve Bolt's Programmer";
  type  = "par";
  connection_type = parallel;
  vcc   = 4,5,6,7,8;
  reset = 3;
  sck   = 2;
  mosi  = 9;
  miso  = 11;
;

programmer
  id     = "picoweb";
  desc   = "Picoweb Programming Cable, http://www.picoweb.net/";
  type   = "par";
  connection_type = parallel;
  reset  = 2;
  sck    = 3;
  mosi   = 4;
  miso   = 13;
;

programmer
  id    = "abcmini";
  desc  = "ABCmini Board, aka Dick Smith HOTCHIP";
  type  = "par";
  connection_type = parallel;
  reset = 4;
  sck   = 3;
  mosi  = 2;
  miso  = 10;
;

programmer
  id    = "futurlec";
  desc  = "Futurlec.com programming cable.";
  type  = "par";
  connection_type = parallel;
  reset = 3;
  sck   = 2;
  mosi  = 1;
  miso  = 10;
;


# From the contributor of the "xil" jtag cable:
# The "vcc" definition isn't really vcc (the cable gets its power from
# the programming circuit) but is necessary to switch one of the
# buffer lines (trying to add it to the "buff" lines doesn't work in
# avrdude versions before 5.5j).
# With this, TMS connects to RESET, TDI to MOSI, TDO to MISO and TCK
# to SCK (plus vcc/gnd of course)
programmer
  id    = "xil";
  desc  = "Xilinx JTAG cable";
  type  = "par";
  connection_type = parallel;
  mosi  = 2;
  sck   = 3;
  reset = 4;
  buff  = 5;
  miso  = 13;
  vcc   = 6;
;


programmer
  id = "dapa";
  desc = "Direct AVR Parallel Access cable";
  type = "par";
  connection_type = parallel;
  vcc   = 3;
  reset = 16;
  sck = 1;
  mosi = 2;
  miso = 11;
;

programmer
  id    = "atisp";
  desc  = "AT-ISP V1.1 programming cable for AVR-SDK1 from <http://micro-research.co.th/> micro-research.co.th";
  type  = "par";
  connection_type = parallel;
  reset = ~6;
  sck   = ~8;
  mosi  = ~7;
  miso  = ~10;
;

programmer
  id    = "ere-isp-avr";
  desc  = "ERE ISP-AVR <http://www.ere.co.th/download/sch050713.pdf>";
  type  = "par";
  connection_type = parallel;
  reset = ~4;
  sck   = 3;
  mosi  = 2;
  miso  = 10;
;

programmer
  id    = "blaster";
  desc  = "Altera ByteBlaster";
  type  = "par";
  connection_type = parallel;
  sck   = 2;
  miso  = 11;
  reset = 3;
  mosi  = 8;
  buff  = 14;
;

# It is almost same as pony-stk200, except vcc on pin 5 to auto
# disconnect port (download on http://electropol.free.fr/spip/spip.php?article27)
programmer parent "pony-stk200"
  id    = "frank-stk200";
  desc  = "Frank STK200";
  buff  = ; # delete buff pin assignment
  vcc   = 5;
;

# The AT98ISP Cable is a simple parallel dongle for AT89 family.
# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=2877
programmer
  id = "89isp";
  desc = "Atmel at89isp cable";
  type = "par";
  connection_type = parallel;
  reset = 17;
  sck = 1;
  mosi = 2;
  miso = 10;
;


#This programmer bitbangs GPIO lines using the Linux sysfs GPIO interface
#
#To enable it set the configuration below to match the GPIO lines connected to the
#relevant ISP header pins and uncomment the entry definition. In case you don't
#have the required permissions to edit this system wide config file put the
#entry in a separate <your name>.conf file and use it with -C+<your name>.conf
#on the command line.
#
#To check if your avrdude build has support for the linuxgpio programmer compiled in,
#use -c?type on the command line and look for linuxgpio in the list. If it's not available
#you need pass the --enable-linuxgpio=yes option to configure and recompile avrdude.
#
#programmer
#  id    = "linuxgpio";
#  desc  = "Use the Linux sysfs interface to bitbang GPIO lines";
#  type  = "linuxgpio";
#  reset = ?;
#  sck   = ?;
#  mosi  = ?;
#  miso  = ?;
#;

# some ultra cheap programmers use bitbanging on the
# serialport.
#
# PC - DB9 - Pins for RS232:
#
# GND   5   -- |O
#              |   O| <-   9   RI
# DTR   4   <- |O   |
#              |   O| <-   8   CTS
# TXD   3   <- |O   |
#              |   O| ->   7   RTS
# RXD   2   -> |O   |
#              |   O| <-   6   DSR
# DCD   1   -> |O
#
# Using RXD is currently not supported.
# Using RI is not supported under Win32 but is supported under Posix.

# serial ponyprog design (dasa2 in uisp)
# reset=!txd sck=rts mosi=dtr miso=cts

programmer
  id    = "ponyser";
  desc  = "design ponyprog serial, reset=!txd sck=rts mosi=dtr miso=cts";
  type  = "serbb";
  connection_type = serial;
  reset = ~3;
  sck   = 7;
  mosi  = 4;
  miso  = 8;
;

# Same as above, different name
# reset=!txd sck=rts mosi=dtr miso=cts

programmer parent "ponyser"
  id    = "siprog";
  desc  = "Lancos SI-Prog <http://www.lancos.com/siprogsch.html>";
;

# unknown (dasa in uisp)
# reset=rts sck=dtr mosi=txd miso=cts

programmer
  id    = "dasa";
  desc  = "serial port banging, reset=rts sck=dtr mosi=txd miso=cts";
  type  = "serbb";
  connection_type = serial;
  reset = 7;
  sck   = 4;
  mosi  = 3;
  miso  = 8;
;

# unknown (dasa3 in uisp)
# reset=!dtr sck=rts mosi=txd miso=cts

programmer
  id    = "dasa3";
  desc  = "serial port banging, reset=!dtr sck=rts mosi=txd miso=cts";
  type  = "serbb";
  connection_type = serial;
  reset = ~4;
  sck   = 7;
  mosi  = 3;
  miso  = 8;
;

# C2N232i (jumper configuration "auto")
# reset=dtr sck=!rts mosi=!txd miso=!cts

programmer
  id    = "c2n232i";
  desc  = "serial port banging, reset=dtr sck=!rts mosi=!txd miso=!cts";
  type  = "serbb";
  connection_type = serial;
  reset = 4;
  sck   = ~7;
  mosi  = ~3;
  miso  = ~8;
;

#------------------------------------------------------------
# ATTiny841
#------------------------------------------------------------


part
     id            = "t841";
     desc          = "ATtiny841";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x07, 0x17;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
               0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
               0x99, 0xE1, 0xBB, 0xAC;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     ##avr910_devcode   = 0x20;
     signature        = 0x1e 0x93 0x15;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout   = 200;
    stabdelay   = 100;
    cmdexedelay   = 25;
    synchloops    = 32;
    bytedelay   = 0;
    pollindex   = 3;
    pollvalue   = 0x53;
    predelay    = 1;
    postdelay   = 1;
    pollmethod    = 1;

    hvsp_controlstack   =
        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
    hventerstabdelay    = 100;
    hvspcmdexedelay     = 0;
    synchcycles         = 6;
    latchcycles         = 1;
    togglevtg           = 1;
    poweroffdelay       = 25;
    resetdelayms        = 0;
    resetdelayus        = 70;
    hvleavestabdelay    = 100;
    resetdelay          = 25;
    chiperasepolltimeout = 40;
    chiperasetime       = 0;
    programfusepolltimeout = 25;
    programlockpolltimeout = 25;

    #ocdrev              = 1;

     memory "eeprom"
         size            = 512;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

  loadpage_lo = "  1   1   0   0      0   0   0   1",
        "  0   0   0   0      0   0   0   0",
        "  0   0   0   0      0   0  a1  a0",
        "  i   i   i   i      i   i   i   i";

  writepage = "  1   1   0   0      0   0   1   0",
        "  0   0   x   x      x   x   x   x",
        "  x  a6  a5  a4     a3  a2   0   0",
        "  x   x   x   x      x   x   x   x";

  mode    = 0x41;
  delay   = 6;
  blocksize = 4;
  readsize  = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 8192;
         page_size       = 16;
         num_pages       = 512;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  x   x  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   x   x  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1   1   0  0",
                           "  0  0  0  0  a11 a10 a9 a8",
                           " a7 a6 a5  a4  a3  x  x  x",
                           "  x  x  x  x   x  x  x  x";

  mode    = 0x41;
  delay   = 12;
  blocksize = 32;
  readsize  = 256;
       ;
#   ATtiny841 has Signature Bytes: 0x1E 0x93 0x0C.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;

     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  x x x x  x x i i";
         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 1;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;


#------------------------------------------------------------
# ATTiny441
#------------------------------------------------------------


part
     id            = "t441";
     desc          = "ATtiny441";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x07, 0x17;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
               0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
               0x99, 0xE1, 0xBB, 0xAC;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     ##avr910_devcode   = 0x20;
     signature        = 0x1e 0x92 0x15;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout   = 200;
    stabdelay   = 100;
    cmdexedelay   = 25;
    synchloops    = 32;
    bytedelay   = 0;
    pollindex   = 3;
    pollvalue   = 0x53;
    predelay    = 1;
    postdelay   = 1;
    pollmethod    = 1;

    hvsp_controlstack   =
        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
    hventerstabdelay    = 100;
    hvspcmdexedelay     = 0;
    synchcycles         = 6;
    latchcycles         = 1;
    togglevtg           = 1;
    poweroffdelay       = 25;
    resetdelayms        = 0;
    resetdelayus        = 70;
    hvleavestabdelay    = 100;
    resetdelay          = 25;
    chiperasepolltimeout = 40;
    chiperasetime       = 0;
    programfusepolltimeout = 25;
    programlockpolltimeout = 25;

    #ocdrev              = 1;

     memory "eeprom"
         size            = 512;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

  loadpage_lo = "  1   1   0   0      0   0   0   1",
        "  0   0   0   0      0   0   0   0",
        "  0   0   0   0      0   0  a1  a0",
        "  i   i   i   i      i   i   i   i";

  writepage = "  1   1   0   0      0   0   1   0",
        "  0   0   x   x      x   x   x   x",
        "  x  a6  a5  a4     a3  a2   0   0",
        "  x   x   x   x      x   x   x   x";

  mode    = 0x41;
  delay   = 6;
  blocksize = 4;
  readsize  = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 4096;
         page_size       = 16;
         num_pages       = 256;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0  0 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0  0 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  x   x  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   x   x  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1   1   0  0",
                           "  0  0  0  0  0 a10 a9 a8",
                           " a7 a6 a5  a4  a3  x  x  x",
                           "  x  x  x  x   x  x  x  x";

  mode    = 0x41;
  delay   = 12;
  blocksize = 32;
  readsize  = 256;
       ;
#   ATtiny441 has Signature Bytes: 0x1E 0x92 0x0C.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;

     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  x x x x  x x i i";
         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 1;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;

#------------------------------------------------------------
# BEGIN: ATtiny1634.
#
# From http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&p=983337#983337
#------------------------------------------------------------

part
    id              = "t1634";
    desc            = "ATtiny1634";
     has_debugwire = yes;
     flash_instr   = 0xB6, 0x01, 0x11;
     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
                0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
                0x99, 0xF9, 0xBB, 0xAF;
    stk500_devcode  = 0x86;
    # avr910_devcode = 0x;
    signature       = 0x1e 0x94 0x12;
    pagel           = 0xd7;
    bs2             = 0xc2;
    chip_erase_delay = 15000;
    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
                       "x x x x x x x x x x x x x x x x";

    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
                       "x x x x x x x x x x x x x x x x";

    timeout         = 200;
    stabdelay       = 100;
    cmdexedelay     = 25;
    synchloops      = 32;
    bytedelay       = 0;
    pollindex       = 3;
    pollvalue       = 0x53;
    predelay        = 1;
    postdelay       = 1;
    pollmethod      = 1;

    pp_controlstack     =
   0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
   0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
   0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
   0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    resetdelay          = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    memory "eeprom"
        paged           = no;
        page_size       = 4;
        size            = 256;
        min_write_delay = 3600;
        max_write_delay = 3600;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read            = " 1 0 1 0 0 0 0 0",
                          " 0 0 0 x x x x a8",
                          " a7 a6 a5 a4 a3 a2 a1 a0",
                          " o o o o o o o o";

        write           = " 1 1 0 0 0 0 0 0",
                          " 0 0 0 x x x x a8",
                          " a7 a6 a5 a4 a3 a2 a1 a0",
                          " i i i i i i i i";

   loadpage_lo   = "  1   1   0   0      0   0   0   1",
           "  0   0   0   0      0   0   0   0",
           "  0   0   0   0      0   0  a1  a0",
           "  i   i   i   i      i   i   i   i";

   writepage   = "  1   1   0   0      0   0   1   0",
           "  0   0   x   x      x   x   x  a8",
           " a7  a6  a5  a4     a3  a2   0   0",
           "  x   x   x   x      x   x   x   x";

   mode      = 0x41;
   delay      = 5;
   blocksize   = 4;
   readsize   = 256;
        ;

    memory "flash"
        paged           = yes;
        size            = 16384;
        page_size       = 32;
        num_pages       = 512;
        min_write_delay = 4500;
        max_write_delay = 4500;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read_lo         = " 0 0 1 0 0 0 0 0",
                          " 0 0 0 a12 a11 a10 a9 a8",
                          " a7 a6 a5 a4 a3 a2 a1 a0",
                          " o o o o o o o o";

        read_hi          = " 0 0 1 0 1 0 0 0",
                           " 0 0 0 a12 a11 a10 a9 a8",
                           " a7 a6 a5 a4 a3 a2 a1 a0",
                           " o o o o o o o o";

        loadpage_lo     = " 0 1 0 0 0 0 0 0",
                          " 0 0 0 x x x x x",
                          " x x x x a3 a2 a1 a0",
                          " i i i i i i i i";

        loadpage_hi     = " 0 1 0 0 1 0 0 0",
                          " 0 0 0 x x x x x",
                          " x x x x a3 a2 a1 a0",
                          " i i i i i i i i";

        writepage       = " 0 1 0 0 1 1 0 0",
                          " 0 0 0 a12 a11 a10 a9 a8",
                          " a7 a6 a5 a4 x x x x",
                          " x x x x x x x x";

        mode        = 0x41;
        delay       = 6;
        blocksize   = 128;
        readsize    = 256;

        ;

    memory "lfuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
                          "x x x x x x x x o o o o o o o o";

        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
                          "x x x x x x x x i i i i i i i i";
        ;

    memory "hfuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
                          "x x x x x x x x o o o o o o o o";

        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
                          "x x x x x x x x i i i i i i i i";
        ;

    memory "efuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1 0 0 0 0   0 0 0 0 1 0 0 0",
                          "x x x x x x x x   o o o o o o o o";

        write           = "1 0 1 0 1 1 0 0   1 0 1 0 0 1 0 0",
                          "x x x x x x x x   1 1 1 i i i i i";
        ;

    memory "lock"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1 1 0 0 0   0 0 0 0 0 0 0 0",
                          "x x x x x x x x   o o o o o o o o";

        write           = "1 0 1 0 1 1 0 0   1 1 1 x x x x x",
                          "x x x x x x x x   1 1 1 1 1 1 i i";
        ;

    memory "calibration"
        size            = 1;
        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
                          "0 0 0 0 0 0 0 0 o o o o o o o o";
        ;

    memory "signature"
        size            = 3;
        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
                          "x x x x x x a1 a0 o o o o o o o o";
        ;
;

#------------------------------------------------------------
# END: ATtiny1634.
#------------------------------------------------------------


#------------------------------------------------------------
# BEGIN: ATtiny828.
#
#------------------------------------------------------------

part
    id              = "t828";
    desc            = "ATtiny828";
     has_debugwire = yes;
     flash_instr   = 0xB6, 0x01, 0x11;
     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
                0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
                0x99, 0xF9, 0xBB, 0xAF;
    stk500_devcode  = 0x86;
    # avr910_devcode = 0x;
    signature       = 0x1e 0x93 0x14;
    pagel           = 0xd7;
    bs2             = 0xc2;
    chip_erase_delay = 15000;
    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
                       "x x x x x x x x x x x x x x x x";

    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
                       "x x x x x x x x x x x x x x x x";

    timeout         = 200;
    stabdelay       = 100;
    cmdexedelay     = 25;
    synchloops      = 32;
    bytedelay       = 0;
    pollindex       = 3;
    pollvalue       = 0x53;
    predelay        = 1;
    postdelay       = 1;
    pollmethod      = 1;

    pp_controlstack     =
   0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
   0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
   0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
   0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    resetdelay          = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    memory "eeprom"
        paged           = no;
        page_size       = 4;
        size            = 256;
        min_write_delay = 3600;
        max_write_delay = 3600;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read            = " 1 0 1 0 0 0 0 0",
                          " 0 0 0 x x x x a8",
                          " a7 a6 a5 a4 a3 a2 a1 a0",
                          " o o o o o o o o";

        write           = " 1 1 0 0 0 0 0 0",
                          " 0 0 0 x x x x a8",
                          " a7 a6 a5 a4 a3 a2 a1 a0",
                          " i i i i i i i i";

   loadpage_lo   = "  1   1   0   0      0   0   0   1",
                   "  0   0   0   0      0   0   0   0",
                   "  0   0   0   0      0   0  a1  a0",
                   "  i   i   i   i      i   i   i   i";

writepage   = "  1   1   0   0      0   0   1   0",
              "  0   0   x   x      x   x   x  a8",
              " a7  a6  a5  a4     a3  a2   0   0",
              "  x   x   x   x      x   x   x   x";

   mode      = 0x41;
   delay      = 5;
   blocksize   = 4;
   readsize   = 256;
        ;

    memory "flash"
        paged           = yes;
        size            = 8192;
        page_size       = 64;
        num_pages       = 128;
        min_write_delay = 4500;
        max_write_delay = 4500;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read_lo         = " 0 0 1 0 0 0 0 0",
                          " 0 0 0 0 a11 a10 a9 a8",
                          " a7 a6 a5 a4 a3 a2 a1 a0",
                          " o o o o o o o o";

        read_hi          = " 0 0 1 0 1 0 0 0",
                           " 0 0 0 0 a11 a10 a9 a8",
                           " a7 a6 a5 a4 a3 a2 a1 a0",
                           " o o o o o o o o";

        loadpage_lo     = " 0 1 0 0 0 0 0 0",
                          " 0 0 0 x x x x x",
                          " x x x a4 a3 a2 a1 a0",
                          " i i i i i i i i";

        loadpage_hi     = " 0 1 0 0 1 0 0 0",
                          " 0 0 0 x x x x x",
                          " x x x a4 a3 a2 a1 a0",
                          " i i i i i i i i";

        writepage       = " 0 1 0 0 1 1 0 0",
                          " 0 0 0 0 a11 a10 a9 a8",
                          " a7 a6 a5 x x x x x",
                          " x x x x x x x x";

        mode        = 0x41;
        delay       = 6;
        blocksize   = 128;
        readsize    = 256;

        ;

    memory "lfuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
                          "x x x x x x x x o o o o o o o o";

        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
                          "x x x x x x x x i i i i i i i i";
        ;

    memory "hfuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
                          "x x x x x x x x o o o o o o o o";

        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
                          "x x x x x x x x i i i i i i i i";
        ;

    memory "efuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
                          "x x x x x x x x o o o o o o o o";

        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
                          "x x x x x x x x 1 1 1 i i i i i";
        ;

    memory "lock"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
                          "x x x x x x x x o o o o o o o o";

        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
                          "x x x x x x x x 1 1 i i i i i i";
        ;

    memory "calibration"
        size            = 1;
        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
                          "0 0 0 0 0 0 0 0 o o o o o o o o";
        ;

    memory "signature"
        size            = 3;
        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
                          "x x x x x x a1 a0 o o o o o o o o";
        ;
;

#------------------------------------------------------------
# END: ATtiny828.
#------------------------------------------------------------

#------------------------------------------------------------
# ATtiny87
#------------------------------------------------------------

# Changes against ATtiny167 (beside IDs)
#    memory "flash"
#        size            = 8192;
#        num_pages       = 64;

part
     id            = "t87";
     desc          = "ATtiny87";
     has_debugwire = yes;
     flash_instr   = 0xB6, 0x01, 0x11;
     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4,
               0x00, 0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB,
               0xBF, 0x99, 0xF9, 0xBB, 0xAF;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     avr910_devcode   = 0x20;
     signature        = 0x1e 0x93 0x87;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout     = 200;
    stabdelay       = 100;
    cmdexedelay     = 25;
    synchloops      = 32;
    bytedelay       = 0;
    pollindex       = 3;
    pollvalue       = 0x53;
    predelay        = 1;
    postdelay       = 1;
    pollmethod      = 0;

    pp_controlstack     =
        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,
        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,
        0x06, 0x16, 0x46, 0x56, 0x0A, 0x1A, 0x4A, 0x5A,
        0x1E, 0x7C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 20;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    idr                 = 0x00;
    spmcr               = 0x57;
    allowfullpagebitstream = no;

     memory "eeprom"
         size            = 512;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0    0 0 x x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0    0 0 x x  x x x a8",
                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

  loadpage_lo   = "  1   1   0   0      0   0   0   1",
        "  0   0   0   0      0   0   0   0",
        "  0   0   0   0      0   0  a1  a0",
        "  i   i   i   i      i   i   i   i";

  writepage = "  1   1   0   0      0   0   1   0",
        "  0   0   x   x      x   x   x   x",
        "  0   0  a5  a4     a3  a2   0   0",
        "  x   x   x   x      x   x   x   x";

  mode      = 0x41;
  delay     = 10;
  blocksize = 4;
  readsize  = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 8192;
         page_size       = 128;
         num_pages       = 64;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0  a12  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2   a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0  a12  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2   a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x  a5  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x  a5  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1   1   0  0",
                           "  0  0  0  0  a11 a10 a9 a8",
                           " a7 a6 a5  x   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

  mode      = 0x41;
  delay     = 10;
  blocksize = 64;
  readsize  = 256;
       ;
#   ATtiny87 has Signature Bytes: 0x1E 0x93 0x87.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;

     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  x x x x  x x i i";
         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 1;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;

#------------------------------------------------------------
# ATtiny167
#------------------------------------------------------------

part
     id            = "t167";
     desc          = "ATtiny167";
     has_debugwire = yes;
     flash_instr   = 0xB6, 0x01, 0x11;
     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4,
               0x00, 0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB,
               0xBF, 0x99, 0xF9, 0xBB, 0xAF;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     avr910_devcode   = 0x20;
     signature        = 0x1e 0x94 0x87;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout     = 200;
    stabdelay       = 100;
    cmdexedelay     = 25;
    synchloops      = 32;
    bytedelay       = 0;
    pollindex       = 3;
    pollvalue       = 0x53;
    predelay        = 1;
    postdelay       = 1;
    pollmethod      = 0;

    pp_controlstack     =
        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,
        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,
        0x06, 0x16, 0x46, 0x56, 0x0A, 0x1A, 0x4A, 0x5A,
        0x1E, 0x7C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 20;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    idr                 = 0x00;
    spmcr               = 0x57;
    allowfullpagebitstream = no;

     memory "eeprom"
         size            = 512;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0    0 0 x x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0    0 0 x x  x x x a8",
                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

  loadpage_lo   = "  1   1   0   0      0   0   0   1",
        "  0   0   0   0      0   0   0   0",
        "  0   0   0   0      0   0  a1  a0",
        "  i   i   i   i      i   i   i   i";

  writepage = "  1   1   0   0      0   0   1   0",
        "  0   0   x   x      x   x   x   x",
        "  0   0  a5  a4     a3  a2   0   0",
        "  x   x   x   x      x   x   x   x";

  mode      = 0x41;
  delay     = 10;
  blocksize = 4;
  readsize  = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 16384;
         page_size       = 128;
         num_pages       = 128;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0  a12  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2   a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0  a12  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2   a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x  a5  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x  a5  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

          writepage       = "  0  1  0  0   1   1   0  0",
                           "  0  0  0  a12  a11 a10 a9 a8",
                           " a7 a6 x  x   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

  mode      = 0x41;
  delay     = 10;
  blocksize = 64;
  readsize  = 256;
       ;
#   ATtiny167 has Signature Bytes: 0x1E 0x94 0x87.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;

     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  x x x x  x x i i";
         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 1;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;


#------------------------------------------------------------
# ATtiny88
#------------------------------------------------------------

part
    id               = "t88";
    desc             = "ATtiny88";
     has_debugwire = yes;
     flash_instr   = 0xB6, 0x01, 0x11;
     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
                     0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
                     0x99, 0xF9, 0xBB, 0xAF;
    stk500_devcode   = 0x73;
#    avr910_devcode   = 0x;
    signature        = 0x1e 0x93 0x11;
    pagel            = 0xd7;
    bs2              = 0xc2;
    chip_erase_delay = 15000;
    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                       "x x x x  x x x x    x x x x  x x x x";

    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                       "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    pp_controlstack     =
        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    resetdelay          = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    ocdrev              = 1;

    memory "eeprom"
        paged           = no;
        page_size       = 4;
        size            = 64;
        min_write_delay = 3600;
        max_write_delay = 3600;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read            = "  1   0   1   0      0   0   0   0",
                          "  0   0   0   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2  a1  a0",
                          "  o   o   o   o      o   o   o   o";

        write           = "  1   1   0   0      0   0   0   0",
                          "  0   0   0   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 20;
        blocksize       = 4;
        readsize        = 64;
      ;
    memory "flash"
        paged           = yes;
        size            = 8192;
        page_size       = 64;
        num_pages       = 128;
        min_write_delay = 4500;
        max_write_delay = 4500;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read_lo         = "  0   0   1   0    0   0   0   0",
                          "  0   0   0   0  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        read_hi         = "  0   0   1   0    1   0   0   0",
                          "  0   0   0   0  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        loadpage_lo     = "  0   1   0   0      0   0   0   0",
                          "  0   0   0   x      x   x   x   x",
                          "  x   x   x  a4     a3  a2  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        loadpage_hi     = "  0   1   0   0      1   0   0   0",
                          "  0   0   0   x      x   x   x   x",
                          "  x   x   x  a4     a3  a2  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  0   1   0   0      1   1   0   0",
                          "  0   0   0   0    a11 a10  a9  a8",
                          " a7  a6  a5   x      x   x   x   x",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 64;
        readsize        = 256;
      ;

    memory "lfuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
                          "x x x x  x x x x   o o o o  o o o o";

        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
                          "x x x x  x x x x   i i i i  i i i i";
      ;

    memory "hfuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
                          "x x x x  x x x x   o o o o  o o o o";

        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
                          "x x x x  x x x x   i i i i  i i i i";
      ;

    memory "efuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
                          "x x x x  x x x x   o o o o  o o o o";

        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
                          "x x x x  x x x x   x x x x  x x x i";
      ;

    memory "lock"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
                          "x x x x  x x x x   o o o o  o o o o";

        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
                          "x x x x  x x x x   x x i i  i i i i";
      ;

    memory "calibration"
        size            = 1;
        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
      ;

    memory "signature"
        size            = 3;
        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
      ;
  ;





#------------------------------------------------------------
# ATtiny48
#------------------------------------------------------------

part
    id               = "t48";
    desc             = "ATtiny48";
     has_debugwire = yes;
     flash_instr   = 0xB6, 0x01, 0x11;
     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
                     0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
                     0x99, 0xF9, 0xBB, 0xAF;
    stk500_devcode   = 0x73;
#    avr910_devcode   = 0x;
    signature        = 0x1e 0x92 0x09;
    pagel            = 0xd7;
    bs2              = 0xc2;
    chip_erase_delay = 15000;
    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                       "x x x x  x x x x    x x x x  x x x x";

    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                       "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    pp_controlstack     =
        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    resetdelay          = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    ocdrev              = 1;

    memory "eeprom"
        paged           = no;
        page_size       = 4;
        size            = 64;
        min_write_delay = 3600;
        max_write_delay = 3600;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read            = "  1   0   1   0      0   0   0   0",
                          "  0   0   0   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2  a1  a0",
                          "  o   o   o   o      o   o   o   o";

        write           = "  1   1   0   0      0   0   0   0",
                          "  0   0   0   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 20;
        blocksize       = 4;
        readsize        = 64;
      ;
    memory "flash"
        paged           = yes;
        size            = 4096;
        page_size       = 64;
        num_pages       = 64;
        min_write_delay = 4500;
        max_write_delay = 4500;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read_lo         = "  0   0   1   0    0   0   0   0",
                          "  0   0   0   0  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        read_hi         = "  0   0   1   0    1   0   0   0",
                          "  0   0   0   0  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        loadpage_lo     = "  0   1   0   0      0   0   0   0",
                          "  0   0   0   x      x   x   x   x",
                          "  x   x   x  a4     a3  a2  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        loadpage_hi     = "  0   1   0   0      1   0   0   0",
                          "  0   0   0   x      x   x   x   x",
                          "  x   x   x  a4     a3  a2  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  0   1   0   0      1   1   0   0",
                          "  0   0   0   0    a11 a10  a9  a8",
                          " a7  a6  a5   x      x   x   x   x",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 64;
        readsize        = 256;
      ;

    memory "lfuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
                          "x x x x  x x x x   o o o o  o o o o";

        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
                          "x x x x  x x x x   i i i i  i i i i";
      ;

    memory "hfuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
                          "x x x x  x x x x   o o o o  o o o o";

        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
                          "x x x x  x x x x   i i i i  i i i i";
      ;

    memory "efuse"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
                          "x x x x  x x x x   o o o o  o o o o";

        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
                          "x x x x  x x x x   1 1 1 1  1 1 1 i";
      ;

    memory "lock"
        size            = 1;
        min_write_delay = 4500;
        max_write_delay = 4500;
        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
                          "x x x x  x x x x   o o o o  o o o o";

        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
                          "x x x x  x x x x   1 1 i i  i i i i";
      ;

    memory "calibration"
        size            = 1;
        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
      ;

    memory "signature"
        size            = 3;
        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
      ;
  ;


#------------------------------------------------------------
# ATtiny261
#------------------------------------------------------------
# Close to ATtiny26

part
    id                  = "t261";
    desc                = "ATtiny261";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x00, 0x10;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
#    stk500_devcode      = 0x21;
#    avr910_devcode      = 0x5e;
    signature           = 0x1e 0x91 0x0c;
    pagel               = 0xb3;
    bs2                 = 0xb2;
    chip_erase_delay    = 15000;

    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
                          "x x x x  x x x x   x x x x  x x x x";

    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
                          "x x x x  x x x x   x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 0;

    pp_controlstack     =
        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 2;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    ocdrev              = 1;

    memory "eeprom"
        paged           = no;
        size            = 128;
        page_size       = 4;
        num_pages       = 32;
        min_write_delay = 4000;
        max_write_delay = 4000;
        readback_p1     = 0xff;
        readback_p2     = 0xff;

        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";

        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 10;
        blocksize       = 4;
        readsize        = 256;
    ;

    memory "flash"
        paged           = yes;
        size            = 2048;
        page_size       = 32;
        num_pages       = 64;
        min_write_delay = 4500;
        max_write_delay = 4500;
        readback_p1     = 0xff;
        readback_p2     = 0xff;

        read_lo         = "  0  0  1  0   0  0  0  0",
                          "  x  x  x  x   x  x a9 a8",
                          " a7 a6 a5 a4  a3 a2 a1 a0",
                          "  o  o  o  o   o  o  o  o";

        read_hi         = "  0  0  1  0   1  0  0  0",
                          "  x  x  x  x   x  x a9 a8",
                          " a7 a6 a5 a4  a3 a2 a1 a0",
                          "  o  o  o  o   o  o  o  o";

        loadpage_lo     = "  0  1  0  0   0  0  0  0",
                          "  x  x  x  x   x  x  x  x",
                          "  x  x  x  x  a3 a2 a1 a0",
                          "  i  i  i  i   i  i  i  i";

        loadpage_hi     = "  0  1  0  0   1  0  0  0",
                          "  x  x  x  x   x  x  x  x",
                          "  x  x  x  x  a3 a2 a1 a0",
                          "  i  i  i  i   i  i  i  i";

        writepage       = "  0  1  0  0   1  1  0  0",
                          "  x  x  x  x   x  x a9 a8",
                          " a7 a6 a5 a4   x  x  x  x",
                          "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 32;
        readsize        = 256;
    ;

    memory "signature"
        size            = 3;
        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
    ;

    memory "lock"
        size            = 1;
        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
                          "x  x  x  x   x  x  x  x    x x x x  x x o o";

        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
        min_write_delay = 4500;
        max_write_delay = 4500;
    ;

    memory "lfuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                          "x x x x  x x x x  i i i i  i i i i";

        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "hfuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                          "x x x x  x x x x  i i i i  i i i i";

        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "efuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
                          "x x x x  x x x x   x x x x  x x x i";

        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
                          "x x x x  x x x x   x x x x  x x x o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "calibration"
        size            = 1;
        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
    ;

;


#------------------------------------------------------------
# ATtiny461
#------------------------------------------------------------
# Close to ATtiny261

part
    id                  = "t461";
    desc                = "ATtiny461";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x00, 0x10;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
#    stk500_devcode      = 0x21;
#    avr910_devcode      = 0x5e;
    signature           = 0x1e 0x92 0x08;
    pagel               = 0xb3;
    bs2                 = 0xb2;
    chip_erase_delay    = 15000;

    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
                          "x x x x  x x x x   x x x x  x x x x";

    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
                          "x x x x  x x x x   x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 0;

    pp_controlstack     =
        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 2;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    ocdrev              = 1;

    memory "eeprom"
        paged           = no;
        size            = 256;
        page_size       = 4;
        num_pages       = 64;
        min_write_delay = 4000;
        max_write_delay = 4000;
        readback_p1     = 0xff;
        readback_p2     = 0xff;

        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x x",
                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";

        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x x",
                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          " a7  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 10;
        blocksize       = 4;
        readsize        = 256;
    ;

    memory "flash"
        paged           = yes;
        size            = 4096;
        page_size       = 64;
        num_pages       = 64;
        min_write_delay = 4500;
        max_write_delay = 4500;
        readback_p1     = 0xff;
        readback_p2     = 0xff;

        read_lo         = "  0  0  1  0   0   0  0  0",
                          "  x  x  x  x   x a10 a9 a8",
                          " a7 a6 a5 a4  a3  a2 a1 a0",
                          "  o  o  o  o   o   o  o  o";

        read_hi         = "  0  0  1  0   1   0  0  0",
                          "  x  x  x  x   x a10 a9 a8",
                          " a7 a6 a5 a4  a3  a2 a1 a0",
                          "  o  o  o  o   o   o  o  o";

        loadpage_lo     = "  0  1  0  0   0  0  0  0",
                          "  x  x  x  x   x  x  x  x",
                          "  x  x  x a4  a3 a2 a1 a0",
                          "  i  i  i  i   i  i  i  i";

        loadpage_hi     = "  0  1  0  0   1  0  0  0",
                          "  x  x  x  x   x  x  x  x",
                          "  x  x  x a4  a3 a2 a1 a0",
                          "  i  i  i  i   i  i  i  i";

        writepage       = "  0  1  0  0   1   1  0  0",
                          "  x  x  x  x   x a10 a9 a8",
                          " a7 a6 a5  x   x   x  x  x",
                          "  x  x  x  x   x   x  x  x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 64;
        readsize        = 256;
    ;

    memory "signature"
        size            = 3;
        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
    ;

    memory "lock"
        size            = 1;
        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
                          "x  x  x  x   x  x  x  x    x x x x  x x o o";

        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
        min_write_delay = 4500;
        max_write_delay = 4500;
    ;

    memory "lfuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                          "x x x x  x x x x  i i i i  i i i i";

        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "hfuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                          "x x x x  x x x x  i i i i  i i i i";

        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "efuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
                          "x x x x  x x x x   x x x x  x x x i";

        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
                          "x x x x  x x x x   x x x x  x x x o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "calibration"
        size            = 1;
        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
    ;

;


#------------------------------------------------------------
# ATtiny861
#------------------------------------------------------------
# Close to ATtiny461

part
    id                  = "t861";
    desc                = "ATtiny861";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x00, 0x10;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
#    stk500_devcode      = 0x21;
#    avr910_devcode      = 0x5e;
    signature           = 0x1e 0x93 0x0d;
    pagel               = 0xb3;
    bs2                 = 0xb2;
    chip_erase_delay    = 15000;

    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
                          "x x x x  x x x x   x x x x  x x x x";

    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
                          "x x x x  x x x x   x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 0;

    pp_controlstack     =
        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 2;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

    ocdrev              = 1;

    memory "eeprom"
        paged           = no;
        size            = 512;
        num_pages       = 128;
        page_size       = 4;
        min_write_delay = 4000;
        max_write_delay = 4000;
        readback_p1     = 0xff;
        readback_p2     = 0xff;

        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x a8",
                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o  o";

        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x a8",
                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i  i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x  a8",
                          " a7  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 10;
        blocksize       = 4;
        readsize        = 256;
    ;

    memory "flash"
        paged           = yes;
        size            = 8192;
        page_size       = 64;
        num_pages       = 128;
        min_write_delay = 4500;
        max_write_delay = 4500;
        readback_p1     = 0xff;
        readback_p2     = 0xff;

        read_lo         = "  0  0  1  0   0   0  0  0",
                          "  x  x  x  x a11 a10 a9 a8",
                          " a7 a6 a5 a4  a3  a2 a1 a0",
                          "  o  o  o  o   o   o  o  o";

        read_hi         = "  0  0  1  0   1   0  0  0",
                          "  x  x  x  x a11 a10 a9 a8",
                          " a7 a6 a5 a4  a3  a2 a1 a0",
                          "  o  o  o  o   o   o  o  o";

        loadpage_lo     = "  0  1  0  0   0  0  0  0",
                          "  x  x  x  x   x  x  x  x",
                          "  x  x  x a4  a3 a2 a1 a0",
                          "  i  i  i  i   i  i  i  i";

        loadpage_hi     = "  0  1  0  0   1  0  0  0",
                          "  x  x  x  x   x  x  x  x",
                          "  x  x  x a4  a3 a2 a1 a0",
                          "  i  i  i  i   i  i  i  i";

        writepage       = "  0  1  0  0   1   1  0  0",
                          "  x  x  x  x a11 a10 a9 a8",
                          " a7 a6 a5  x   x   x  x  x",
                          "  x  x  x  x   x   x  x  x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 64;
        readsize        = 256;
    ;

    memory "signature"
        size            = 3;
        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
    ;

    memory "lock"
        size            = 1;
        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
                          "x  x  x  x   x  x  x  x    x x x x  x x o o";

        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
        min_write_delay = 4500;
        max_write_delay = 4500;
    ;

    memory "lfuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                          "x x x x  x x x x  i i i i  i i i i";

        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "hfuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                          "x x x x  x x x x  i i i i  i i i i";

        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "efuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
                          "x x x x  x x x x   x x x x  x x x i";

        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
                          "x x x x  x x x x   x x x x  x x x o";
        min_write_delay = 4500;
        max_write_delay = 4500;
      ;

    memory "calibration"
        size            = 1;
        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
    ;

;


#------------------------------------------------------------
# ATtiny25
#------------------------------------------------------------

part
     id            = "t25";
     desc          = "ATtiny25";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x02, 0x12;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     avr910_devcode   = 0x20;
     signature        = 0x1e 0x91 0x08;
     reset            = io;
     chip_erase_delay = 400000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    hvsp_controlstack   =
        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
    hventerstabdelay    = 100;
    hvspcmdexedelay     = 0;
    synchcycles         = 6;
    latchcycles         = 1;
    togglevtg           = 1;
    poweroffdelay       = 25;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 100;
    resetdelay          = 25;
    chiperasepolltimeout = 40;
    chiperasetime       = 0;
    programfusepolltimeout = 25;
    programlockpolltimeout = 25;

    ocdrev              = 1;

     memory "eeprom"
         size            = 128;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 12;
        blocksize       = 4;
        readsize        = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 2048;
         page_size       = 32;
         num_pages       = 64;
         min_write_delay = 30000;
         max_write_delay = 30000;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0    0   0  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0    0   0  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   x   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   x   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1  1  0  0",
                           "  0  0  0  0   0  0 a9 a8",
                           " a7 a6 a5 a4   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 12;
        blocksize       = 32;
        readsize        = 256;
       ;
#   ATtiny25 has Signature Bytes: 0x1E 0x91 0x08.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;
     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  1 1 i i  i i i i";
        read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 2;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;

#------------------------------------------------------------
# ATtiny45
#------------------------------------------------------------

part
     id            = "t45";
     desc          = "ATtiny45";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x02, 0x12;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     avr910_devcode   = 0x20;
     signature        = 0x1e 0x92 0x06;
     reset            = io;
     chip_erase_delay = 400000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    hvsp_controlstack     =
        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    hvspcmdexedelay     = 0;
    synchcycles         = 6;
    latchcycles         = 1;
    togglevtg           = 1;
    poweroffdelay       = 25;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 100;
    resetdelay          = 25;
    chiperasepolltimeout = 40;
    chiperasetime       = 0;
    programfusepolltimeout = 25;
    programlockpolltimeout = 25;

    ocdrev              = 1;

     memory "eeprom"
         size            = 256;
         page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          " a7  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 12;
        blocksize       = 4;
        readsize        = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 4096;
         page_size       = 64;
         num_pages       = 64;
         min_write_delay = 30000;
         max_write_delay = 30000;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0    0  a10 a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0    0  a10 a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1  1  0  0",
                           "  0  0  0  0   0 a10 a9 a8",
                           " a7 a6 a5  x   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 12;
        blocksize       = 32;
        readsize        = 256;
       ;
#   ATtiny45 has Signature Bytes: 0x1E 0x92 0x08. (Data sheet 2586C-AVR-06/05 (doc2586.pdf) indicates otherwise!)
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;
     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  1 1 i i  i i i i";
        read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 2;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;

#------------------------------------------------------------
# ATtiny85
#------------------------------------------------------------

part
     id            = "t85";
     desc          = "ATtiny85";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x02, 0x12;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     avr910_devcode   = 0x20;
     signature        = 0x1e 0x93 0x0b;
     reset            = io;
     chip_erase_delay = 400000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    hvsp_controlstack   =
        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
    hventerstabdelay    = 100;
    hvspcmdexedelay     = 0;
    synchcycles         = 6;
    latchcycles         = 1;
    togglevtg           = 1;
    poweroffdelay       = 25;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 100;
    resetdelay          = 25;
    chiperasepolltimeout = 40;
    chiperasetime       = 0;
    programfusepolltimeout = 25;
    programlockpolltimeout = 25;

    ocdrev              = 1;

     memory "eeprom"
         size            = 512;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x  a8",
                          " a7  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 12;
        blocksize       = 4;
        readsize        = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 8192;
         page_size       = 64;
         num_pages       = 128;
         min_write_delay = 30000;
         max_write_delay = 30000;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1   1   0  0",
                           "  0  0  0  0  a11 a10 a9 a8",
                           " a7 a6 a5  x   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 12;
        blocksize       = 32;
        readsize        = 256;
       ;
#   ATtiny85 has Signature Bytes: 0x1E 0x93 0x08.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;
     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  1 1 i i  i i i i";
        read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 2;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;


#------------------------------------------------------------
# ATtiny24
#------------------------------------------------------------

part
     id            = "t24";
     desc          = "ATtiny24";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x07, 0x17;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     avr910_devcode   = 0x20;
     signature        = 0x1e 0x91 0x0b;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    hvsp_controlstack   =
        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
    hventerstabdelay    = 100;
    hvspcmdexedelay     = 0;
    synchcycles         = 6;
    latchcycles         = 1;
    togglevtg           = 1;
    poweroffdelay       = 25;
    resetdelayms        = 0;
    resetdelayus        = 70;
    hvleavestabdelay    = 100;
    resetdelay          = 25;
    chiperasepolltimeout = 40;
    chiperasetime       = 0;
    programfusepolltimeout = 25;
    programlockpolltimeout = 25;

    ocdrev              = 1;

     memory "eeprom"
         size            = 128;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 4;
        readsize        = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 2048;
         page_size       = 32;
         num_pages       = 64;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0    0   0  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0    0   0  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   x   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   x   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1  1  0  0",
                           "  0  0  0  0   0  0 a9 a8",
                           " a7 a6 a5 a4   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 32;
        readsize        = 256;
       ;
#   ATtiny24 has Signature Bytes: 0x1E 0x91 0x0B.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;
     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  x x x x  x x i i";
         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 1;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;

#------------------------------------------------------------
# ATtiny44
#------------------------------------------------------------

part
     id            = "t44";
     desc          = "ATtiny44";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x07, 0x17;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     avr910_devcode   = 0x20;
     signature        = 0x1e 0x92 0x07;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    hvsp_controlstack   =
        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
    hventerstabdelay    = 100;
    hvspcmdexedelay     = 0;
    synchcycles         = 6;
    latchcycles         = 1;
    togglevtg           = 1;
    poweroffdelay       = 25;
    resetdelayms        = 0;
    resetdelayus        = 70;
    hvleavestabdelay    = 100;
    resetdelay          = 25;
    chiperasepolltimeout = 40;
    chiperasetime       = 0;
    programfusepolltimeout = 25;
    programlockpolltimeout = 25;

    ocdrev              = 1;

     memory "eeprom"
         size            = 256;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 4;
        readsize        = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 4096;
         page_size       = 64;
         num_pages       = 64;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0    0  a10 a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0    0  a10 a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1  1  0  0",
                           "  0  0  0  0   0 a10 a9 a8",
                           " a7 a6 a5  x   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 32;
        readsize        = 256;
       ;
#   ATtiny44 has Signature Bytes: 0x1E 0x92 0x07.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;
     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  x x x x  x x i i";
         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 1;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;

#------------------------------------------------------------
# ATtiny84
#------------------------------------------------------------

part
     id            = "t84";
     desc          = "ATtiny84";
     has_debugwire = yes;
     flash_instr   = 0xB4, 0x07, 0x17;
     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
## no STK500 devcode in XML file, use the ATtiny45 one
     stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
     avr910_devcode   = 0x20;
     signature        = 0x1e 0x93 0x0c;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    hvsp_controlstack   =
        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
    hventerstabdelay    = 100;
    hvspcmdexedelay     = 0;
    synchcycles         = 6;
    latchcycles         = 1;
    togglevtg           = 1;
    poweroffdelay       = 25;
    resetdelayms        = 0;
    resetdelayus        = 70;
    hvleavestabdelay    = 100;
    resetdelay          = 25;
    chiperasepolltimeout = 40;
    chiperasetime       = 0;
    programfusepolltimeout = 25;
    programlockpolltimeout = 25;

    ocdrev              = 1;

     memory "eeprom"
         size            = 512;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 4;
        readsize        = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 8192;
         page_size       = 64;
         num_pages       = 128;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0  a11 a10  a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x  a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

         writepage       = "  0  1  0  0   1   1   0  0",
                           "  0  0  0  0  a11 a10 a9 a8",
                           " a7 a6 a5  x   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 32;
        readsize        = 256;
       ;
#   ATtiny84 has Signature Bytes: 0x1E 0x93 0x0C.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;

     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  x x x x  x x i i";
         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;

     memory "calibration"
         size            = 1;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;

#------------------------------------------------------------
# ATtiny2313
#------------------------------------------------------------

part
     id            = "t2313";
     desc          = "ATtiny2313";
     has_debugwire = yes;
     flash_instr   = 0xB2, 0x0F, 0x1F;
     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
     stk500_devcode   = 0x23;
##   Use the ATtiny26 devcode:
     avr910_devcode   = 0x5e;
     signature        = 0x1e 0x91 0x0a;
     pagel            = 0xD4;
     bs2              = 0xD6;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    pp_controlstack     =
        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,
        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,
        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,
        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

     memory "eeprom"
         size            = 256;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 4;
        readsize        = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 2048;
         page_size       = 32;
         num_pages       = 64;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;

#####

         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0    0   0 a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0    0   0 a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

# The information in the data sheet of April/2004 is wrong, this works:
         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   x   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

# The information in the data sheet of April/2004 is wrong, this works:
         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   x   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

# The information in the data sheet of April/2004 is wrong, this works:
         writepage       = "  0  1  0  0   1  1  0  0",
                           "  0  0  0  0   0  0  a9 a8",
                           " a7 a6 a5  a4   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 64;
        readsize        = 256;
       ;
#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;
     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  1 1 i i  i i i i";
         read           = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                          "x x x x  x x x x  x x o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;
# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.
# The information in the data sheet of April/2004 is wrong, this works:

     memory "calibration"
         size            = 2;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;


#------------------------------------------------------------
# ATtiny4313
#------------------------------------------------------------

part
     id            = "t4313";
     desc          = "ATtiny4313";
     has_debugwire = yes;
     flash_instr   = 0xB2, 0x0F, 0x1F;
     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                     0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,
                     0x99, 0xE1, 0xBB, 0xAC;
     stk500_devcode   = 0x23;
##   Use the ATtiny26 devcode:
     avr910_devcode   = 0x5e;
     signature        = 0x1e 0x92 0x0d;
     pagel            = 0xD4;
     bs2              = 0xD6;
     reset            = io;
     chip_erase_delay = 15000;

     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout             = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;

    pp_controlstack     =
        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,
        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,
        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,
        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 15;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;

     memory "eeprom"
         size            = 256;
        paged           = no;
        page_size       = 4;
         min_write_delay = 4000;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;
         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

        loadpage_lo     = "  1   1   0   0      0   0   0   1",
                          "  0   0   0   0      0   0   0   0",
                          "  0   0   0   0      0   0  a1  a0",
                          "  i   i   i   i      i   i   i   i";

        writepage       = "  1   1   0   0      0   0   1   0",
                          "  0   0   x   x      x   x   x   x",
                          "  x  a6  a5  a4     a3  a2   0   0",
                          "  x   x   x   x      x   x   x   x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 4;
        readsize        = 256;
       ;
     memory "flash"
         paged           = yes;
         size            = 4096;
         page_size       = 64;
         num_pages       = 64;
         min_write_delay = 4500;
         max_write_delay = 4500;
         readback_p1     = 0xff;
         readback_p2     = 0xff;

#####

         read_lo         = "  0   0   1   0    0   0   0   0",
                           "  0   0   0   0    0  a10 a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

         read_hi         = "  0   0   1   0    1   0   0   0",
                           "  0   0   0   0    0  a10 a9  a8",
                           " a7  a6  a5  a4   a3  a2  a1  a0",
                           "  o   o   o   o    o   o   o   o";

# The information in the data sheet of April/2004 is wrong, this works:
         loadpage_lo     = "  0   1   0   0    0   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

# The information in the data sheet of April/2004 is wrong, this works:
         loadpage_hi     = "  0   1   0   0    1   0   0   0",
                           "  0   0   0   x    x   x   x   x",
                           "  x   x   x   a4   a3  a2  a1  a0",
                           "  i   i   i   i    i   i   i   i";

# The information in the data sheet of April/2004 is wrong, this works:
         writepage       = "  0  1  0  0   1  1  0  0",
                           "  0  0  0  0   0  a10  a9 a8",
                           " a7 a6 a5  x   x  x  x  x",
                           "  x  x  x  x   x  x  x  x";

        mode            = 0x41;
        delay           = 6;
        blocksize       = 64;
        readsize        = 256;
       ;
#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.
     memory "signature"
         size            = 3;
         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
       ;
     memory "lock"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                           "x x x x  x x x x  1 1 i i  i i i i";
         read           = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
                          "x x x x  x x x x  x x o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "lfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "hfuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                           "x x x x  x x x x  i i i i  i i i i";

         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
       ;

     memory "efuse"
         size            = 1;
         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                           "x x x x  x x x x  x x x x  x x x i";

         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                           "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 9000;
        max_write_delay = 9000;
     ;
# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.
# The information in the data sheet of April/2004 is wrong, this works:

     memory "calibration"
         size            = 2;
         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
     ;
  ;

#------------------------------------------------------------
# ATtiny43U
#------------------------------------------------------------

part
    id            = "t43u";
    desc          = "ATtiny43u";
    has_debugwire = yes;
    flash_instr   = 0xB4, 0x07, 0x17;
    eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
                         0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
                         0x99, 0xE1, 0xBB, 0xAC;
    stk500_devcode   = 0x14;
##  avr910_devcode   = ?;
##  Try the AT90S2313 devcode:
    avr910_devcode   = 0x20;
    signature        = 0x1e 0x92 0x0C;
    reset            = io;
    chip_erase_delay = 1000;

    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                        "x x x x  x x x x    x x x x  x x x x";

    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                        "x x x x  x x x x    x x x x  x x x x";

    timeout                     = 200;
    stabdelay           = 100;
    cmdexedelay         = 25;
    synchloops          = 32;
    bytedelay           = 0;
    pollindex           = 3;
    pollvalue           = 0x53;
    predelay            = 1;
    postdelay           = 1;
    pollmethod          = 1;
        pp_controlstack = 0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E, 0x4E, 0x5E,
                                         0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E, 0x06, 0x16, 0x46, 0x56,
                                         0x0A, 0x1A, 0x4A, 0x5A, 0x1E, 0x7C, 0x00, 0x01, 0x00, 0x00,
                                         0x00, 0x00;
    hventerstabdelay    = 100;
    progmodedelay       = 0;
    hvspcmdexedelay     = 0;
    latchcycles         = 5;
    togglevtg           = 1;
    poweroffdelay       = 20;
    resetdelayms        = 1;
    resetdelayus        = 0;
    hvleavestabdelay    = 15;
    resetdelay          = 15;
    chiperasepulsewidth = 0;
    chiperasepolltimeout = 10;
    programfusepulsewidth = 0;
    programfusepolltimeout = 5;
    programlockpulsewidth = 0;
    programlockpolltimeout = 5;
    memory "eeprom"
                size            = 64;
                paged                   = yes;
                page_size       = 4;
                num_pages               = 16;
                min_write_delay = 4000;
                max_write_delay = 4500;
                readback_p1     = 0xff;
                readback_p2     = 0xff;
                read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
                                   "0  0 a4  a3 a2 a1 a0   o o o o  o o o o";

                write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
                                   "0  0 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

                loadpage_lo     = "  1   1   0   0      0   0   0   1",
                                  "  0   0   0   0      0   0   0   0",
                                  "  0   0   0   0      0   0  a1  a0",
                                  "  i   i   i   i      i   i   i   i";

                writepage       = "  1   1   0   0      0   0   1   0",
                                  "  0   0   x   x      x   x   x   x",
                                  "  0   0  a5  a4     a3  a2   0   0",
                                  "  x   x   x   x      x   x   x   x";

                mode            = 0x41;
                delay           = 5;
                blocksize       = 4;
                readsize        = 256;
        ;
    memory "flash"
        paged           = yes;
        size            = 4096;
        page_size       = 64;
        num_pages       = 64;
        min_write_delay = 4500;
        max_write_delay = 4500;
        readback_p1     = 0xff;
        readback_p2     = 0xff;

        read_lo         = "  0   0   1   0    0   0   0   0",
                          "  0   0   0   0    0  a10 a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        read_hi         = "  0   0   1   0    1   0   0   0",
                          "  0   0   0   0    0  a10 a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        loadpage_lo     = "  0   1   0   0    0   0   0   0",
                          "  0   0   0   x    x   x   x   x",
                          "  x   x   x  a4   a3  a2  a1  a0",
                          "  i   i   i   i    i   i   i   i";

        loadpage_hi     = "  0   1   0   0    1   0   0   0",
                          "  0   0   0   x    x   x   x   x",
                          "  x   x   x  a4   a3  a2  a1  a0",
                          "  i   i   i   i    i   i   i   i";

        writepage       = "  0  1  0  0   1  1  0  0",
                          "  0  0  0  0   0 a10 a9 a8",
                          " a7 a6 a5  x   x  x  x  x",
                          "  x  x  x  x   x  x  x  x";

                mode            = 0x41;
                delay           = 10;
                blocksize       = 64;
                readsize        = 256;
       ;
    memory "signature"
        size            = 3;
        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
    ;
    memory "lock"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
                          "x x x x  x x x x  1 1 i i  i i i i";
        min_write_delay = 4500;
        max_write_delay = 4500;
    ;

    memory "lfuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                          "x x x x  x x x x  i i i i  i i i i";

        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
        ;

    memory "hfuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                          "x x x x  x x x x  i i i i  i i i i";

        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
        ;

    memory "efuse"
        size            = 1;
        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                          "x x x x  x x x x  x x x x  x x x i";

        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                          "x x x x  x x x x  o o o o  o o o o";
        min_write_delay = 4500;
        max_write_delay = 4500;
    ;

    memory "calibration"
        size            = 2;
        read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
                          "0  0  0  0   0  0  0  a0   o o o o  o o o o";
    ;
;
